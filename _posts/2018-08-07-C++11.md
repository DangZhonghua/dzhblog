---
layout: post
title: "C++ 11 新特性"
date: 2018-08-07 23:29:01
categories: C++
tags:
---

--------------------------
# notes for 深入理解C++11 ：C++11 新特性解析与应用 

### noexcept 修饰符与操作符
> 为更加简洁的处理异常， c++11 中增加了 **noexcept** 如果被noexcept 修饰的函数爆出异常，则直接terminate

```c++
noexcept keyword
int excpt_func(int ) noexcept;
void excpt_ func() noexcept(const expression);

template <class T> void fun() noexcept( noexcept( T())){};

```
### c++ 11 支持类成员的就地初始化
> c++ 98 只支持静态整型常量的就地初始化
 
```c++
#include <string>
#include <vector>
using namespace std;

class cinitexp
{
    public:
    cinitexp(){}
    ~cinitexp(){}
    private:
    vector<int> vm={1,0,56,78,90};
    string sm="c++11"
    int i = 1;
};

```

### c++11 初始化列表(initialization list)

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    int a[] = {1,2,3,5,6}; //c++ 98 对内置的类型支持初始化列表
    vector<int> vi={1,3,4,5}; // c++11 对自定义类型的初始化列表
}


```

### non-static member sizeof
```c++
#include<vector>
#include<iostream>
using namespace std;

 class CTest
 {
     static int a;
     vector<int> bv;
 };

int main()
{
    cout<<sizeof(CTest::a)<<endl;
    cout<<sizeof(CTest::bv)<<endl; //c++ 11. 这确实方便了很多
    
    return 0;
}


```

### extend friend keyword

c++ 98, *** friend class Cfriend"
c++ 11, *** friend Cfriend"
c++ 11 中无须在friend 声明中使用keyword "class"
虽然 在 C++ 11 中 这是一个小的改进， 却会带来一点应用的变化—— 程序员可以为类模板声明友元了。

```c++
class P; 
template ＜ typename T ＞ 
class People{ friend T; }; 
People ＜ P ＞ PP;// 类型 P 在这里 是 People 类型 的 友 元 People ＜ int ＞ Pi;
//对于 int 类型 模板 参数， 友元声明 被 忽略
```

### function template support default argument

```c++
void DefParm( int m= 3){}// c++ 98 编译 通过， c++ 11 编译 通过
template ＜ typename T= int ＞
 class DefClass{};// c++ 98 编译 通过， c++ 11 编译 通过 
 template ＜ typename T= int ＞ void DefTempParm(){};// c++ 98 编译 失败， c++ 11 编译 通过
```

### 局部和匿名类型作模板实参

```c++
template <typename T>
 class X{};

 template <typename T>
 void TempFun( T t){}; 
 struct A{} a;
 struct{ int i;} b;// b 是 匿名 类型 变量 
 typedef struct{ int i;} B;// B 是 匿名 类型 
 void Fun() { struct C{} c;// C 是 局部 类型 
 X <A> x1;// C++ 98 通过， C++ 11 通过 
 X <B> x2;// C++ 98 错误， C++ 11 通过 
 X <C> x3;// C++ 98 错误， C++ 11 通过 
 TempFun( a);// C++ 98 通过， C++ 11 通过 
 TempFun( b);// C++ 98 错误， C++ 11 通过 
 TempFun( c);// C++ 98 错误， C++ 11 通过

```
不过值得指出的是， 虽然匿名类型可以被模板参数所接受了， 但并不意味着以下写法可以被接受，

```c++
template < typename T > 
struct MyTemplate{}; 
int main(){ MyTemplate <struct{ int a;} > t;// 无法 编译 通过, 匿名 类型 的 声明 不能 在 模板 实 参 位置 
return 0;
}
```

  

### c++11 右值引用与移动语义

### c++ 11 final, override key word.

```c++
  
  class base
  {
      virtual int test1() final;
  };
  class derive:public base
  {
      virtual int test1(); // compile failure if using c++11
  };

// using final: prevent some common function be changed


class base1
{
    virtual int test1();
};
class base2
{
   virtual int test2();  
};

class Drived:public base1, base2
{
  virtual int test2() override;  // this function must overload the one which is a member of one of its base class
};


```