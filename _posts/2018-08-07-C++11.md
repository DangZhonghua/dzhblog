---
layout: post
title: "C++ 11 新特性"
date: 2018-08-07 23:29:01
categories: C++
tags:
---

--------------------------
# notes for 深入理解C++11 ：C++11 新特性解析与应用 

### noexcept 修饰符与操作符
> 为更加简洁的处理异常， c++11 中增加了 **noexcept** 如果被noexcept 修饰的函数爆出异常，则直接terminate

```c++
noexcept keyword
int excpt_func(int ) noexcept;
void excpt_ func() noexcept(const expression);

template <class T> void fun() noexcept( noexcept( T())){};

```
### c++ 11 支持类成员的就地初始化
> c++ 98 只支持静态整型常量的就地初始化
 
```c++
#include <string>
#include <vector>
#include <map>
using namespace std;

class cinitexp
{
    public:
    cinitexp(){}
    ~cinitexp(){}
    private:
    vector<int> vm={1,0,56,78,90};
    double d{1.02};
    string sm="c++11"
    int i = 1;
};

```

### c++11 初始化列表(initialization list)

```c++
#include <iostream>
#include <vector>
#include <map>
using namespace std;

int main()
{
    int a[] = {1,2,3,5,6}; //c++ 98 对内置的类型支持初始化列表
    vector<int> vi={1,3,4,5}; // c++11 对自定义类型的初始化列表
    //map<int,string> ml{ {1,"1"},{2,"2"} };
}


```

### non-static member sizeof
```c++
#include<vector>
#include<iostream>
using namespace std;

 class CTest
 {
     static int a;
     vector<int> bv;
 };

int main()
{
    cout<<sizeof(CTest::a)<<endl;
    cout<<sizeof(CTest::bv)<<endl; //c++ 11. 这确实方便了很多
    
    return 0;
}


```

### extend friend keyword

c++ 98, *** friend class Cfriend"
c++ 11, *** friend Cfriend"
c++ 11 中无须在friend 声明中使用keyword "class"
虽然 在 C++ 11 中 这是一个小的改进， 却会带来一点应用的变化—— 程序员可以为类模板声明友元了。

```c++
class P; 
template ＜ typename T ＞ 
class People{ friend T; }; 
People ＜ P ＞ PP;// 类型 P 在这里 是 People 类型 的 友 元 People ＜ int ＞ Pi;
//对于 int 类型 模板 参数， 友元声明 被 忽略
```

### function template support default argument

```c++
void DefParm( int m= 3){}// c++ 98 编译 通过， c++ 11 编译 通过
template ＜ typename T= int ＞
 class DefClass{};// c++ 98 编译 通过， c++ 11 编译 通过 
 template ＜ typename T= int ＞ void DefTempParm(){};// c++ 98 编译 失败， c++ 11 编译 通过
```

### 局部和匿名类型作模板实参

```c++
template <typename T>
 class X{};

 template <typename T>
 void TempFun( T t){}; 
 struct A{} a;
 struct{ int i;} b;// b 是 匿名 类型 变量 
 typedef struct{ int i;} B;// B 是 匿名 类型 
 void Fun() { struct C{} c;// C 是 局部 类型 
 X <A> x1;// C++ 98 通过， C++ 11 通过 
 X <B> x2;// C++ 98 错误， C++ 11 通过 
 X <C> x3;// C++ 98 错误， C++ 11 通过 
 TempFun( a);// C++ 98 通过， C++ 11 通过 
 TempFun( b);// C++ 98 错误， C++ 11 通过 
 TempFun( c);// C++ 98 错误， C++ 11 通过

```
不过值得指出的是， 虽然匿名类型可以被模板参数所接受了， 但并不意味着以下写法可以被接受，

```c++
template < typename T > 
struct MyTemplate{}; 
int main(){ MyTemplate <struct{ int a;} > t;// 无法 编译 通过, 匿名 类型 的 声明 不能 在 模板 实 参 位置 
return 0;
}
```

  

### c++11 右值引用与移动语义

### c++ 11 final, override key word.

```c++
  
  class base
  {
      virtual int test1() final;
  };
  class derive:public base
  {
      virtual int test1(); // compile failure if using c++11
  };

// using final: prevent some common function be changed


class base1
{
    virtual int test1();
};
class base2
{
   virtual int test2();  
};

class Drived:public base1, base2
{
  virtual int test2() override;  // this function must overload the one which is a member of one of its base class
};


```
### template alias

```c++
template ＜ typename T ＞ using MapString= std:: map ＜ T, char* ＞; 
MapString ＜ int ＞ numberedString;
```
在这里， 我们“ 模板 式” 地 使用 了 using 关键字， 将 std:: map ＜ T, char* ＞ 定义 为了 一个 MapString 类型， 之后 我们 还可以 使用 类型 参数 对 MapString 进行 类型 的 实例 化， 而使 用 typedef 将 无法 达到 这样 的 效果。

### auto 类型推导
C++ 11 中 类型 推导 的 实现 的 方式 之一 就是 重 定义 了 auto(a type-specifier) 关键字。 另外 一个 现实 是 decltype。

```c++
#include<iostream>
using namespace std;

int main()
{
    auto s = "hello world"; // s is char* actually
    cout<<s<<endl;
    return 0;
}

```

```c++
int main()
{
double foo(); auto x= 1;// x 的 类型 为 int 
auto y= foo();// y 的 类型 为 double 
struct m{ int i;} str; 
auto str1= str;// str1 的 类型 是 struct m 
auto z;// 无法 推导， 无法 通过 编译 
z= x; 
} 
//编译 选项: g++ -std= c++ 11 4- 2- 2. cpp
```
auto 声明 的 变量 必须 被 初始化， 以使 编译器 能够 从其 初始化 表达式 中 推
导出 其 类型。 从 这个 意义上 来讲， auto 并非 一种“ 类型” 声明， 而是 一个 类型 声 明时 的“ 占位符”， 编译器 在编 译 时 期会 将 auto 替代 为 变量 实际 的 类型。
```c++
#include ＜ string ＞ 
#include ＜ vector ＞ 
void loopover( std:: vector ＜ std:: string ＞＆ vs)
{ 
    for( auto i= vs. begin(); i ＜ vs. end(); i++)
    { 
    //一些 代码 
    }
} 
//编译 选项: g++ -c- std= c++ 11 4- 2- 4. cpp
```


auto 推导 的 一个 最大 优势 就是 在 拥有 初始化 表达式 的 复杂 类型 变量 声明 时 简化 代码。 由于 C++ 的 发展， 声明 变量 类型 也 变得 越来越 复杂， 很多 时候， 名字 空间、 模板 成为 了 类型 的 一部分， 导致 程序员 在 使用 库 的 时候 如履薄冰。
auto 的 第二个 优势 则在 于 可以 免除 程序员 在 一些 类型 声 明时 的 麻烦， 或者 避免 一些 在 类型 声 明时 的 错误。

auto 的 第三 个 优点 就是 其“ 自 适应” 性 能够 在 一定程度 上 支持 泛 型 的 编程。

